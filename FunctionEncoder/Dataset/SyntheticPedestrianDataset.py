import torch
import numpy as np
from typing import Tuple, Dict
from .BaseDataset import BaseDataset


class SyntheticPedestrianDataset(BaseDataset):
    """
    Dataset for generating synthetic pedestrian trajectories with different walking types.

    Walking Types:
        1. Straight Walking
        2. Circular Walking
        3. Zig-Zag Walking

    Each pedestrian is assigned a walking type and a goal towards which they navigate.
    
    Input Dimensions:
        - input_size = (history_length, feature_dim)
        - feature_dim options:
            - 2: (x, y) positions only
            - 4: (x, y, dx, dy) positions and velocities
            - 6: (x, y, dx, dy, ddx, ddy) positions, velocities, and accelerations
        - history_length: Number of time steps in each sample
    
    The trajectory is split into overlapping subsequences using a sliding window approach.
    For example, with history_length=4 and 100 timesteps:
    - Sample 1: [t1, t2, t3, t4]
    - Sample 2: [t2, t3, t4, t5]
    - ...
    - Sample 97: [t97, t98, t99, t100]
    """

    def __init__(
        self,
        input_size: Tuple[int, int],
        output_size: Tuple[int],
        data_type: str = 'deterministic',
        n_functions: int = 1000,
        n_examples: int = 10,
        n_queries: int = 10,
        dtype: torch.dtype = torch.float32,
        device: str = "auto",
        speed_range: Tuple[float, float] = (0.5, 3.0),
        acceleration_range: Tuple[float, float] = (0.1, 1.0),
        time_step: float = 0.02,
    ) -> None:
        """
        Initializes the SyntheticPedestrianDataset.

        Args:
            input_size (Tuple[int, int]): (history_length, feature_dim)
                - history_length: Number of time steps in each input sample
                - feature_dim: Dimensionality of features at each time step
                    - 2: (x, y) positions only
                    - 4: (x, y, dx, dy) positions and velocities  
                    - 6: (x, y, dx, dy, ddx, ddy) positions, velocities, and accelerations
            output_size (Tuple[int]): (feature_dim,) - dimensionality of the next step prediction
            data_type (str): Type of data generated by the dataset.
            n_functions (int): Number of pedestrian trajectories to generate.
            n_examples (int): Number of example subsequences per trajectory.
            n_queries (int): Number of query subsequences per trajectory.
            dtype (torch.dtype): Data type of the tensors.
            device (str): Device to generate the tensors on.
            speed_range (Tuple[float, float]): Range of speeds for trajectory generation.
            acceleration_range (Tuple[float, float]): Range of accelerations for trajectory generation.
            time_step (float): Time step between trajectory points.
        """
        super(SyntheticPedestrianDataset, self).__init__(
            input_size=input_size,
            output_size=output_size,
            data_type=data_type,
            n_functions=n_functions,
            n_examples=n_examples,
            n_queries=n_queries,
            dtype=dtype,
            device=device,
        )
        assert len(input_size) == 2, "Input size must be a tuple of (history_length, feature_dim)"
        self.walking_types = ["straight", "circular", "zig_zag"]
        self.speed_range = speed_range
        self.acceleration_range = acceleration_range
        self.time_step = time_step
        
        # Parse input dimensions
        self.history_length = input_size[0]
        self.feature_dim = input_size[1]
        
        # Validate feature dimensions
        if self.feature_dim not in [2, 4, 6]:
            raise ValueError(f"Feature dimension {self.feature_dim} not supported. Must be 2, 4, or 6.")
        
        # Validate output size matches feature dimension
        if output_size[0] != self.feature_dim:
            raise ValueError(f"Output size {output_size[0]} must match feature dimension {self.feature_dim}.")
        
        self.include_velocity = self.feature_dim >= 4
        self.include_acceleration = self.feature_dim >= 6
        
        # Calculate required trajectory length for sliding window with next step prediction
        # To get n_examples + n_queries input-output pairs, we need:
        # trajectory_length = n_examples + n_queries + history_length
        # (history_length for input sequence + 1 extra for the prediction target)
        self.trajectory_length = self.n_examples + self.n_queries + self.history_length

    def sample(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor, Dict]:
        """
        Samples a batch of pedestrian trajectories using sliding window approach with next step prediction.

        Returns:
            Tuple containing:
                - example_xs (torch.Tensor): Example input subsequences. Shape: (n_functions, n_examples, history_length, feature_dim)
                - example_ys (torch.Tensor): Example next step targets. Shape: (n_functions, n_examples, feature_dim)
                - query_xs (torch.Tensor): Query input subsequences. Shape: (n_functions, n_queries, history_length, feature_dim)
                - query_ys (torch.Tensor): Query next step targets. Shape: (n_functions, n_queries, feature_dim)
                - info (Dict): Additional information such as walking types, speeds, and accelerations.
        """
        example_xs = torch.zeros(
            (self.n_functions, self.n_examples, *self.input_size), dtype=self.dtype, device=self.device
        )
        example_ys = torch.zeros(
            (self.n_functions, self.n_examples, *self.output_size), dtype=self.dtype, device=self.device
        )
        query_xs = torch.zeros(
            (self.n_functions, self.n_queries, *self.input_size), dtype=self.dtype, device=self.device
        )
        query_ys = torch.zeros(
            (self.n_functions, self.n_queries, *self.output_size), dtype=self.dtype, device=self.device
        )
        info = {"walking_types": [], "speeds": [], "accelerations": []}

        for i in range(self.n_functions):
            walking_type = np.random.choice(self.walking_types)
            speed = np.random.uniform(*self.speed_range)
            acceleration = np.random.uniform(*self.acceleration_range)
            
            info["walking_types"].append(walking_type)
            info["speeds"].append(speed)
            info["accelerations"].append(acceleration)
            
            # Generate full trajectory
            trajectory = self.generate_trajectory(walking_type, speed, acceleration)
            
            # Create sliding window samples with next step prediction
            input_samples, example_target_samples, target_samples = self.create_input_target_pairs(trajectory)
            
            # Split into examples and queries
            example_xs[i] = torch.tensor(input_samples[:self.n_examples], dtype=self.dtype)
            example_ys[i] = torch.tensor(example_target_samples[:self.n_examples], dtype=self.dtype)
            # example_ys[i] = torch.tensor(target_samples[:self.n_examples], dtype=self.dtype)
            query_xs[i] = torch.tensor(input_samples[-self.n_queries:], dtype=self.dtype)
            query_ys[i] = torch.tensor(target_samples[-self.n_queries:], dtype=self.dtype)

        return example_xs, example_ys, query_xs, query_ys, info

    def create_input_target_pairs(self, trajectory: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        Creates input-target pairs from a trajectory using sliding window approach.
        
        Args:
            trajectory (np.ndarray): Full trajectory with shape (trajectory_length, feature_dim)
            
        Returns:
            Tuple of:
                - input_samples (np.ndarray): Input sequences with shape (n_samples, history_length, feature_dim)
                - target_samples (np.ndarray): Next step targets with shape (n_samples, feature_dim)
                
        Example:
            For history_length=4 and trajectory=[t1, t2, t3, t4, t5, t6, ...]:
            - Input sample 1: [t1, t2, t3, t4], Target: t5
            - Input sample 2: [t2, t3, t4, t5], Target: t6
            - ...
        """
        n_samples = len(trajectory) - self.history_length
        input_samples = []
        example_target_samples = []
        target_samples = []
        
        for i in range(n_samples):
            # Input: sequence of history_length steps
            input_seq = trajectory[i:i + self.history_length]
            # Target: the next single step
            example_target_step = trajectory[i + self.history_length - 1] - trajectory[i + self.history_length - 2]
            target_step = trajectory[i + self.history_length] - trajectory[i + self.history_length - 1]
            
            input_samples.append(input_seq)
            example_target_samples.append(example_target_step)
            target_samples.append(target_step)
        
        return np.array(input_samples), np.array(example_target_samples), np.array(target_samples)

    def generate_trajectory(self, walking_type: str, speed: float, acceleration: float) -> np.ndarray:
        """
        Generates a single pedestrian trajectory based on the walking type, speed, and acceleration.

        Args:
            walking_type (str): Type of walking behavior.
            speed (float): Base speed of the pedestrian.
            acceleration (float): Base acceleration magnitude for the pedestrian.

        Returns:
            np.ndarray: Generated trajectory features. Shape: (trajectory_length, feature_dim)
        """
        if walking_type == "straight":
            return self.generate_straight_trajectory(speed, acceleration)
        elif walking_type == "circular":
            return self.generate_circular_trajectory(speed, acceleration)
        elif walking_type == "zig_zag":
            return self.generate_zig_zag_trajectory(speed, acceleration)
        else:
            raise ValueError(f"Unknown walking type: {walking_type}")

    def generate_straight_trajectory(self, speed: float, acceleration: float) -> np.ndarray:
        """
        Generates a straight walking trajectory with velocity and acceleration features.

        Args:
            speed (float): Base speed of the pedestrian.
            acceleration (float): Base acceleration magnitude.

        Returns:
            np.ndarray: Straight trajectory features. Shape: (trajectory_length, feature_dim)
        """
        # Generate position trajectory
        start = np.random.uniform(-10, 10, 2)
        goal = np.random.uniform(-10, 10, 2)
        direction = (goal - start) / np.linalg.norm(goal - start)
        
        positions = []
        velocities = []
        accelerations = []
        
        # Initialize state
        current_pos = start.copy()
        current_vel = direction * speed
        current_acc = np.zeros(2)
        
        # Add some random acceleration variations
        acc_variation = np.random.uniform(-acceleration, acceleration, 2)
        
        for i in range(self.trajectory_length):
            positions.append(current_pos.copy())
            velocities.append(current_vel.copy())
            accelerations.append(current_acc.copy())
            
            # Update with physics
            current_pos += current_vel * self.time_step
            current_vel += current_acc * self.time_step
            
            # Add slight acceleration variations to create more realistic movement
            if i % 5 == 0:  # Change acceleration every few steps
                current_acc = acc_variation * np.random.uniform(0.5, 1.5)
        
        return self._combine_features(positions, velocities, accelerations)

    def generate_circular_trajectory(self, speed: float, acceleration: float) -> np.ndarray:
        """
        Generates a circular walking trajectory with velocity and acceleration features.

        Args:
            speed (float): Base speed of the pedestrian.
            acceleration (float): Base acceleration magnitude.

        Returns:
            np.ndarray: Circular trajectory features. Shape: (trajectory_length, feature_dim)
        """
        center = np.random.uniform(-10, 10, 2)
        radius = np.random.uniform(5, 15)
        
        # Calculate angular velocity from linear speed
        angular_velocity = speed / radius
        
        positions = []
        velocities = []
        accelerations = []
        
        for i in range(self.trajectory_length):
            t = i * self.time_step
            angle = angular_velocity * t
            
            # Position
            pos = center + radius * np.array([np.cos(angle), np.sin(angle)])
            positions.append(pos)
            
            # Velocity (tangential)
            vel = speed * np.array([-np.sin(angle), np.cos(angle)])
            velocities.append(vel)
            
            # Acceleration (centripetal + random variations)
            centripetal_acc = -(speed ** 2 / radius) * np.array([np.cos(angle), np.sin(angle)])
            random_acc = acceleration * np.random.uniform(-0.5, 0.5, 2)
            acc = centripetal_acc + random_acc
            accelerations.append(acc)
        
        return self._combine_features(positions, velocities, accelerations)

    def generate_zig_zag_trajectory(self, speed: float, acceleration: float) -> np.ndarray:
        """
        Generates a zig-zag walking trajectory with velocity and acceleration features.

        Args:
            speed (float): Base speed of the pedestrian.
            acceleration (float): Base acceleration magnitude.

        Returns:
            np.ndarray: Zig-zag trajectory features. Shape: (trajectory_length, feature_dim)
        """
        start = np.random.uniform(-10, 10, 2)
        goal_direction = np.random.uniform(-1, 1, 2)
        goal_direction /= np.linalg.norm(goal_direction)
        orthogonal = np.array([-goal_direction[1], goal_direction[0]])
        zig_amplitude = np.random.uniform(1, 3)
        zig_frequency = np.random.uniform(0.3, 0.8)
        
        positions = []
        velocities = []
        accelerations = []
        
        for i in range(self.trajectory_length):
            t = i * self.time_step
            
            # Position with zig-zag pattern
            base_pos = start + t * speed * goal_direction
            zig_offset = zig_amplitude * np.sin(zig_frequency * t) * orthogonal
            pos = base_pos + zig_offset
            positions.append(pos)
            
            # Velocity (derivative of position)
            base_vel = speed * goal_direction
            zig_vel = zig_amplitude * zig_frequency * np.cos(zig_frequency * t) * orthogonal
            vel = base_vel + zig_vel
            velocities.append(vel)
            
            # Acceleration (derivative of velocity + random variations)
            zig_acc = -zig_amplitude * (zig_frequency ** 2) * np.sin(zig_frequency * t) * orthogonal
            random_acc = acceleration * np.random.uniform(-0.3, 0.3, 2)
            acc = zig_acc + random_acc
            accelerations.append(acc)
        
        return self._combine_features(positions, velocities, accelerations)

    def _combine_features(self, positions: list, velocities: list, accelerations: list) -> np.ndarray:
        """
        Combines position, velocity, and acceleration features based on the feature dimension.

        Args:
            positions (list): List of 2D position arrays.
            velocities (list): List of 2D velocity arrays.
            accelerations (list): List of 2D acceleration arrays.

        Returns:
            np.ndarray: Combined feature array with shape (trajectory_length, feature_dim).
        """
        trajectory = []
        
        for i in range(len(positions)):
            if self.feature_dim == 2:
                # Only positions (x, y)
                features = positions[i]
            elif self.feature_dim == 4:
                # Positions and velocities (x, y, dx, dy)
                features = np.concatenate([positions[i], velocities[i]])
            elif self.feature_dim == 6:
                # Positions, velocities, and accelerations (x, y, dx, dy, ddx, ddy)
                features = np.concatenate([positions[i], velocities[i], accelerations[i]])
            
            trajectory.append(features)
        
        return np.array(trajectory)